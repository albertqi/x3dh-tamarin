theory ExerciseADH
begin

builtins: symmetric-encryption, diffie-hellman

// Step 1
// Generate a fresh secret key, then create long term key and public key for $P
// Also output public component
rule Ltk:
  let publicComponent = 'g'^~sk in
  [ Fr(~sk)]
  -->
  [!Sk($P, ~sk), !Pk($P, publicComponent), Out(publicComponent)]

// Step 2
// For A to initialize a message, need A's public key
// Send key from A to B, and also notation that we started message
rule A_Init:
  [!Pk($A, pkA)]
  --[ ReachAInit() ]->
  [ Out(<$A, $B, pkA>),
    St_A($A, $B)
  ]

// Step 2
rule B_Init:
  // Shared key is doubly-exponentiated base
  let sharedKey = pkA^~skB in
  // To respond, need B's public and secret key, also need A's public key
  // Need to have received message from A
  [ !Sk($B, ~skB), !Pk($A, pkA), !Pk($B, pkB),
    In(<$A, $B, pkA>)
  ]
  --[ ReachBInit(), ResponderKey(sharedKey)
    ]->
    // Compute shared key, then respond with own private key and encoded ack
  [ Out(<senc('ack', sharedKey), $A, $B, 'g'^~skB>)
  ]

// Step 2: A wants to message
rule A_SendMsg:
  // Shared key is doubly-exponentiated base
  let sharedKey = pkB^~skA in
  // To reply, need both public keys, a new message, A's secret key, and existing messages
  [ !Sk($A, ~skA),
    !Pk($A, pkA),
    !Pk($B, pkB),
    Fr(~msg),
    In(<encAck, $A, $B, pkB>),
    St_A($A, $B)
  ]
  --[ ReachASendMsg(),
    MessageWasSent(~msg),
    InitiatorKey(sharedKey),
    // Make sure that both used same shared key
    Eq('ack', sdec(encAck, sharedKey))
    ]->
    // Output encoded message
  [ Out(senc(~msg, sharedKey))
  ]

// This restriction allows you to use the Eq action fact in rules to constrain
// that two terms must be equal. This is used to "compare" two messages or
// terms, e.g., to check that signature verification is equal to true.
// This rule is only commented out right now to suppress a warning that Eq is
// referenced but not used. Un-comment it whenever you want!
restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

lemma Executability:
  exists-trace
  "Ex #t1 #t2 #t3. ReachAInit() @ #t1 & ReachBInit() @ #t2 & ReachASendMsg() @ #t3"

// K(m) @ #t means that the adversary knows message m at timepoint #t.
// Again, the following lemmas are commented out to suppress warnings.
lemma ResponderKeySecrecy:
  "All k #t. ResponderKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma InitiatorKeySecrecy:
  "All k #t. InitiatorKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma SendMsgSecrecy:
  "All m #t. MessageWasSent(m) @ #t ==> not Ex #x. K(m) @ #x"

end
