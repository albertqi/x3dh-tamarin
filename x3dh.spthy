theory X3DH
begin

builtins: asymmetric-encryption, symmetric-encryption, diffie-hellman, hashing, signing

rule IdentityKey:
    let identityKey = 'ik'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateIdentityKey($P, ~sk), !PublicIdentityKey($P, identityKey),
    Out(identityKey) ]

rule SignedPrekey:
    let signedPrekey = 'spk'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateSignedPrekey($P, ~sk), !PublicSignedPrekey($P, signedPrekey),
    Out(signedPrekey) ]

rule B_Init:
    let prekey_sig = !sign(SPKB, pIKB) in
    let OPKB = 'opk'^~sk in
    [ !PrivateIdentityKey($B, pIKB), !PublicIdentityKey($B, IKB), !PublicSignedPrekey($B, SPKB), Fr(~sk) ]
    -->
    [ Out(<$B, IKB, SPKB, prekey_sig, OPKB>) ]

rule A_InitMsg:
    let EKA = 'ek'^~sk in
    let DH1 = IKA^SPKB in
    let DH2 = EKA^IKB in
    let DH3 = EKA^SPKB in
    let DH4 = EKA^OPKB in
    let SK = !hash(DH1, DH2, DH3, DH4) in
    let AD = !hash(senc(IKA, pIKA), senc(IKB, pIKA)) in
    [ !PrivateIdentityKey($A, pIKA), !PublicIdentityKey($A, IKA), Fr(~sk), Fr(~msg)
      In(<$B, IKB, SPKB, prekey_sig, OPKB>) ]
    --[ verify(prekey_sig, SPKB, IKB) ]->
    [ Out(<$A, IKA, EKA, SPKB, senc(<~msg, AD>, SK)>) ]

rule B_RecMsg:
    let EKB = 'ek'^~sk in
    let DH1 = IKB^SPKA in
    let DH2 = EKB^IKA in
    let DH3 = EKB^SPKA in
    let DH4 = EKB^OPKA in
    let SK = !hash(DH1, DH2, DH3, DH4) in
    let AD = !hash(senc(IKB, pIKB), senc(IKA, pIKB)) in
    [ !PrivateIdentityKey($B, pIKB), !PublicIdentityKey($B, IKB), Fr(~sk),
      In(<$A, IKA, EKA, SPKB, senc(<~msg, AD>, SK)>) ]
    -->
    [ Out(sdec(<~msg, AD>, SK)) ]

// Lemmas from the base DH implementation
restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

lemma Executability:
  exists-trace
  "Ex #t1 #t2 #t3. ReachAInit() @ #t1 & ReachBInit() @ #t2 & ReachASendMsg() @ #t3"

// K(m) @ #t means that the adversary knows message m at timepoint #t.
// Again, the following lemmas are commented out to suppress warnings.
lemma ResponderKeySecrecy:
  "All k #t. ResponderKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma InitiatorKeySecrecy:
  "All k #t. InitiatorKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma SendMsgSecrecy:
  "All m #t. MessageWasSent(m) @ #t ==> not Ex #x. K(m) @ #x"

end
