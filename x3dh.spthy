theory X3DH
begin

builtins: asymmetric-encryption, symmetric-encryption, diffie-hellman, hashing, signing

rule IdentityKey:
    let identityKey = 'ik'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateIdentityKey($P, ~sk), !PublicIdentityKey($P, identityKey),
    Out(identityKey) ]

rule SignedPrekey:
    let signedPrekey = 'spk'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateSignedPrekey($P, ~sk), !PublicSignedPrekey($P, signedPrekey),
    Out(signedPrekey) ]

rule OneTimePrekey:
    let oneTimePrekey = 'opk'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateOneTimePrekey($P, ~sk), !PublicOneTimePrekey($P, oneTimePrekey),
    Out(oneTimePrekey) ]

end

rule B_init:
    let prekey_sig = !sign(SPKB, pIKB) in
    [ !PrivateIdentityKey($B, pIKB), !PublicIdentityKey($B, IKB), 
        !PublicSignedPrekey($B, SPKB), !OneTimePrekey($B, OTKB) ]
    -->
    [ Out(<$B, IKB, SPKB, prekey_sig, OTKB>) ]

rule A_initial_message:
    let 
        EKA = 'ek'^~sk
        DH4 =  // Calculate DH parameters
        SK = // KDF using the diffie hellman params to generate secret key.
    in
    [ In(<$B, IKB, SPKB, prekey_sig, OTKB>), Fr(~sk) ]
    --> // Verify Bob's prekey signature
    []


// Lemmas from the base DH implementation
restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

lemma Executability:
  exists-trace
  "Ex #t1 #t2 #t3. ReachAInit() @ #t1 & ReachBInit() @ #t2 & ReachASendMsg() @ #t3"

// K(m) @ #t means that the adversary knows message m at timepoint #t.
// Again, the following lemmas are commented out to suppress warnings.
lemma ResponderKeySecrecy:
  "All k #t. ResponderKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma InitiatorKeySecrecy:
  "All k #t. InitiatorKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma SendMsgSecrecy:
  "All m #t. MessageWasSent(m) @ #t ==> not Ex #x. K(m) @ #x"

end