theory X3DH
begin

builtins: diffie-hellman, hashing, signing, symmetric-encryption

rule IdentityKey:
    let identityKey = 'ik'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateIdentityKey($P, ~sk), !PublicIdentityKey($P, identityKey),
    Out(identityKey) ]

rule SignedPrekey:
    let signedPrekey = 'spk'^~sk in
    [ Fr(~sk) ]
    -->
    [ !PrivateSignedPrekey($P, ~sk), !PublicSignedPrekey($P, signedPrekey),
    Out(signedPrekey) ]

rule B_Init:
    let OPKB = 'opk'^~sk
        prekey_sig = sign(SPKB, pIKB) in
    [ !PrivateIdentityKey($B, pIKB), !PublicIdentityKey($B, IKB), !PublicSignedPrekey($B, SPKB), Fr(~sk) ]
    --[ ReachBInit() ]->
    [ Out(<$B, IKB, SPKB, prekey_sig, OPKB>) ]

rule A_InitMsg:
    let AD = <IKA, IKB>
        SK = h(<DH1, DH2, DH3, DH4>)
        DH4 = 'g'^(EKA*OPKB)
        DH3 = 'g'^(EKA*SPKB)
        DH2 = 'g'^(EKA*IKB)
        DH1 = 'g'^(IKA*SPKB)
        EKA = 'ek'^~sk in
    [ !PublicIdentityKey($A, IKA), Fr(~sk), Fr(~msg),
      In(<$B, IKB, SPKB, prekey_sig, OPKB>) ]
    --[ ReachAInitMsg(), ResponderKey(SK), MessageWasSent(~msg),
        Eq(verify(prekey_sig, SPKB, IKB), true) ]->
    [ Out(<$A, IKA, EKA, SPKB, OPKB, senc(<~msg, AD>, SK)>) ]

rule B_RecMsg:
    let AD = <IKA, IKB>
        SK = h(<DH1, DH2, DH3, DH4>)
        DH4 = 'g'^(EKA*OPKB)
        DH3 = 'g'^(EKA*SPKB)
        DH2 = 'g'^(EKA*IKB)
        DH1 = 'g'^(IKA*SPKB) in
    [ !PublicIdentityKey($B, IKB),
      In(<$A, IKA, EKA, SPKB, OPKB, msg_enc>) ]
    --[ ReachBRecMsg(), InitiatorKey(SK) ]->
    [ Out(sdec(<~msg, AD>, SK)) ]

restriction Eq:
    "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

lemma Executability:
    exists-trace
    "Ex #t1 #t2 #t3. ReachBInit() @ #t1 & ReachAInitMsg() @ #t2 & ReachBRecMsg() @ #t3"

lemma ResponderKeySecrecy:
    "All k #t. ResponderKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma InitiatorKeySecrecy:
    "All k #t. InitiatorKey(k) @ #t ==> not Ex #x. K(k) @ #x"

lemma SendMsgSecrecy:
    "All m #t. MessageWasSent(m) @ #t ==> not Ex #x. K(m) @ #x"

end
